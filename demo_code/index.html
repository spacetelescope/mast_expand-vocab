<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MAST Data Product Tagger</title>
    <style>
        .suggestions-list {
            list-style-type: none;
            margin: 0;
            padding: 0;
            position: absolute;
            z-index: 1000;
            background-color: #fff;
            border: 1px solid #ddd;
        }
        .suggestions-list li {
            padding: 4px;
            cursor: pointer;
        }
        .suggestions-list li:hover {
            background-color: #eee;
        }
        .autocomplete-container {
            position: relative;
        }
        .descendants-text{
            margin-top: 10px
        }
    </style>
</head>

<body>
    <font size="4">
        <h1>MAST Data Product Tagger</h1>
        Please enter each suffix.extension pair that your data collection contains, then start tagging!
        <br>
        <br>
        For example, if your file looks like "*_spec.fits", then suffix="spec", extension="fits", and you might tag this product as "Spectra".
        <br>
        <br>
        You can tag each product type with as many tags as you like!
        <br>
        <br>
    </font>
    <button id="add-row-button">Add Row</button>
    <table id="data-table" border="1">
        <thead>
            <tr>
                <th>Suffix</th>
                <th>Extension</th>
                <th>Data Product Type</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><input type="text" placeholder="spec"></td>
                <td><input type="text" placeholder="fits"></td>
                <td class="autocomplete-container">
                    <input type="text" class="autocomplete-input" placeholder="Spectra">
                    <ul class="suggestions-list"></ul>
                </td>
            </tr>
        </tbody>
    </table>
    <div id="descendants-text" class="descendants-text"></div>
    <button id="export-button">Export CSV</button>
    
    <script>
        // Function to get and jsonify suggestions from the API, to be called from the input event listener in setupTypeahead
        async function fetchSuggestions(query) {
            if (!query) return [];
            const response = await fetch(`http://127.0.0.1:5000/autocomplete?q=${query}`);
            return response.ok ? await response.json() : [];
        }

        // Function to get and jsonify descendants from the API
        async function fetchDescendants(query) {
            if (!query) return [];
            const response = await fetch(`http://127.0.0.1:5000/descendants?q=${query}`);
            return response.ok ? await response.json() : [];
        }

        // Function that sets up listeners for typeahead fields.
        // input is the element with the entered text, suggestionsList is the element where the suggestions will be displayed.
        function setupTypeahead(input, suggestionsList) {
            input.addEventListener('input', async () => {
                const query = input.value.split(',').pop().trim();  // Get the new query (text after the last comma) from input
                const allSuggestions = await fetchSuggestions(query);  // Pass the new query to fetchSuggestions to retrieve all suggestions

                // Get the list of already-selected suggestions
                const selectedSuggestions = input.value.split(',').map(item => item.trim()).filter(Boolean);

                // Filter out the already-selected suggestions
                const filteredSuggestions = allSuggestions.filter(suggestion => !selectedSuggestions.includes(suggestion));

                // Clear previously displayed suggestions
                suggestionsList.innerHTML = '';

                // Add new suggestions
                filteredSuggestions.forEach(suggestion => {  // For each suggestion in filteredSuggestions
                    const item = document.createElement('li');  // Create empty list element
                    item.textContent = suggestion;  // Set the list element equal to the value of the suggestion
                    item.addEventListener('click', async () => {  // Add an event listener for clicks to the list element
                        // If click is detected...
                        const currentValue = input.value.trim();  // Retrieve all text currently in the input field
                        const lastCommaIndex = currentValue.lastIndexOf(',');  // Get position of the last comma in input
                        const cleanValue = lastCommaIndex == -1 ? '' : currentValue.slice(0, lastCommaIndex + 1); // cleanValue is the input with everything after the last comma removed
                        input.value = cleanValue + suggestion + ', ';  // Append the suggestion to cleanValue
                        suggestionsList.style.display = 'none';  // Hide the suggestions list
                        input.focus();  // Refocus the input field
                        input.dispatchEvent(new Event('input'));  // Trigger input event to refresh suggestions

                        // Get descendants of the clicked suggestion
                        const descendants = await fetchDescendants(suggestion);
                        const descendantsText = document.getElementById('descendants-text');
                        if (descendants.length !== 0) {  // If suggestion has any descendants, display them to the user
                            descendantsText.innerHTML = `You selected <strong>${suggestion}</strong>. To help users find your data, you might consider adding some of these more specific concepts if they apply: ${descendants.join(', ')}`;
                        }
                        else descendantsText.innerHTML = `You selected <strong>${suggestion}</strong>.`;
                    });
                    suggestionsList.appendChild(item);  // Add this list element to the displayed suggestions list
                });

                // Display suggestions if there are any suggestions (otherwise, hide suggestions)
                suggestionsList.style.display = filteredSuggestions.length ? 'block' : 'none';
            });

            // Hide suggestions when clicking outside the box+list
            document.addEventListener('click', (e) => {
                if (!input.contains(e.target) && !suggestionsList.contains(e.target)) {
                    suggestionsList.style.display = 'none';
                }
            });
        }

        // Function to add a new row to the table of inputs
        function addRow() {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><input type="text" placeholder="spec"></td>
                <td><input type="text" placeholder="fits"></td>
                <td class="autocomplete-container">
                    <input type="text" class="autocomplete-input" placeholder="Spectra">
                    <ul class="suggestions-list"></ul>
                </td>`;
            document.getElementById('data-table').querySelector('tbody').appendChild(row);
            const input = row.querySelector('.autocomplete-input');  // Input that will be passed into setupTypeahead
            const suggestionsList = row.querySelector('.suggestions-list');  // Element where suggestions will be displayed, to be passed into setupTypeahead
            setupTypeahead(input, suggestionsList);  // Set up typeahead for the autocomplete input in this row
        }

        function exportToCSV() {
            const rows = [];  // Initialize empty rows array
            const table = document.getElementById('data-table');
            const trs = table.querySelectorAll('tbody tr');  // Select all table rows from table body

            trs.forEach(tr => {  // For each table row
                const tds = tr.querySelectorAll('td');  // Return all table cells in the row
                const suffix = tds[0].querySelector('input').value;  // Value of input in first cell is suffix
                const extension = tds[1].querySelector('input').value;  // Value of input in second cell is extension
                // Parse the value of input in third cell: split on commas into an array, remove empty strings
                const dataProductTypes = tds[2].querySelector('input').value.split(',').map(type => type.trim()).filter(Boolean); 

                dataProductTypes.forEach(type => {  // For each parsed element in the dataProductTypes array
                    rows.push([suffix, extension, type]);  // Add this mapping to the rows array
                });
            });

            // Convert array to CSV format
            let csvContent = "data:text/csv;charset=utf-8," 
                + rows.map(row => row.join(',')).join('\n');
            
            // Create a downloadable link and trigger download
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement('a');
            link.setAttribute('href', encodedUri);
            link.setAttribute('download', 'test.csv');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        document.getElementById('add-row-button').addEventListener('click', addRow);
        document.getElementById('export-button').addEventListener('click', exportToCSV);

        // Set up typeahead for the first row
        const input_firstrow = document.querySelector('.autocomplete-input');  // Input that will be passed into setupTypeahead
        const suggestionsList_firstrow = document.querySelector('.suggestions-list');  // Element where suggestions will be displayed, to be passed into setupTypeahead
        setupTypeahead(input_firstrow, suggestionsList_firstrow);  // Set up typeahead for the autocomplete input in this row

    </script>
</body>
</html>